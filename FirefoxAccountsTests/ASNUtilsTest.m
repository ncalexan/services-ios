// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/

#include "CHNumber.h"
#include "NSData+Utils.h"
#import "ASNUtils.h"
#import <XCTest/XCTest.h>


@interface ASNUtilsTest : XCTestCase

@end


@implementation ASNUtilsTest

// 30 2C 02 14 4D 2A 0B EE ED 98 79 7C 04 2B 8E 4C 37 C4 7B 85 13 08 75 DC 02 14 07 F9 BB 30 88 36 D2 30 DE 89 19 83 4A E2 2C 3E 85 EB DE 51

- (void) testEncodeSequenceOfNumbers
{
    unsigned char expected[] = {
        0x30, 0x2C, 0x02, 0x14, 0x4D, 0x2A, 0x0B, 0xEE, 0xED, 0x98, 0x79, 0x7C, 0x04, 0x2B, 0x8E, 0x4C,
        0x37, 0xC4, 0x7B, 0x85, 0x13, 0x08, 0x75, 0xDC, 0x02, 0x14, 0x07, 0xF9, 0xBB, 0x30, 0x88, 0x36,
        0xD2, 0x30, 0xDE, 0x89, 0x19, 0x83, 0x4A, 0xE2, 0x2C, 0x3E, 0x85, 0xEB, 0xDE, 0x51
    };

    NSArray *numbers1 = @[
        [CHNumber numberWithHexString: @"4D2A0BEEED98797C042B8E4C37C47B85130875DC"],
        [CHNumber numberWithHexString: @"07F9BB308836D230DE8919834AE22C3E85EBDE51"]
    ];
    NSData *encoded = [ASNUtils encodeSequenceOfNumbers: numbers1];
    XCTAssertNotNil(encoded);
    
    XCTAssertEqualObjects(encoded, [NSData dataWithBytes:expected length:sizeof expected]);
}

- (void) testDecodeSequenceOfNumbers
{
    unsigned char sequenceData[] = {
        0x30, 0x2C, 0x02, 0x14, 0x4D, 0x2A, 0x0B, 0xEE, 0xED, 0x98, 0x79, 0x7C, 0x04, 0x2B, 0x8E, 0x4C,
        0x37, 0xC4, 0x7B, 0x85, 0x13, 0x08, 0x75, 0xDC, 0x02, 0x14, 0x07, 0xF9, 0xBB, 0x30, 0x88, 0x36,
        0xD2, 0x30, 0xDE, 0x89, 0x19, 0x83, 0x4A, 0xE2, 0x2C, 0x3E, 0x85, 0xEB, 0xDE, 0x51
    };
    NSData *sequence = [NSData dataWithBytes: sequenceData length: sizeof sequenceData];
    
    NSArray *expected = @[
        [CHNumber numberWithHexString: @"4D2A0BEEED98797C042B8E4C37C47B85130875DC"],
        [CHNumber numberWithHexString: @"07F9BB308836D230DE8919834AE22C3E85EBDE51"]
    ];

    NSArray *decoded = [ASNUtils decodeSequenceOfNumbers: sequence];
    XCTAssertNotNil(decoded);
    XCTAssertEqual([expected count], [decoded count]);
    XCTAssertTrue([expected[0] isEqualToNumber: decoded[0]]);
    XCTAssertTrue([expected[1] isEqualToNumber: decoded[1]]);
}

- (void) testRoundTrip
{
    NSArray *numbers1 = @[
        [CHNumber numberWithHexString: @"4D2A0BEEED98797C042B8E4C37C47B85130875DC"],
        [CHNumber numberWithHexString: @"07F9BB308836D230DE8919834AE22C3E85EBDE51"]
    ];

    NSData *encoded = [ASNUtils encodeSequenceOfNumbers: numbers1];
    XCTAssertNotNil(encoded);

    NSArray *numbers2 = [ASNUtils decodeSequenceOfNumbers: encoded];

    XCTAssertNotNil(numbers2);
    XCTAssertEqual([numbers1 count], [numbers2 count]);
    XCTAssertTrue([numbers1[0] isEqualToNumber: numbers2[0]]);
    XCTAssertTrue([numbers1[1] isEqualToNumber: numbers2[1]]);

}

- (void) testDecodeDSASignature
{
    unsigned char encodedSignature[] = {
        0x30, 0x2C, 0x02, 0x14, 0x4D, 0x2A, 0x0B, 0xEE, 0xED, 0x98, 0x79, 0x7C, 0x04, 0x2B, 0x8E, 0x4C,
        0x37, 0xC4, 0x7B, 0x85, 0x13, 0x08, 0x75, 0xDC, 0x02, 0x14, 0x07, 0xF9, 0xBB, 0x30, 0x88, 0x36,
        0xD2, 0x30, 0xDE, 0x89, 0x19, 0x83, 0x4A, 0xE2, 0x2C, 0x3E, 0x85, 0xEB, 0xDE, 0x51
    };

    unsigned char expectedFlattenedSignature[] = {
        0x4D, 0x2A, 0x0B, 0xEE, 0xED, 0x98, 0x79, 0x7C, 0x04, 0x2B, 0x8E, 0x4C, 0x37, 0xC4, 0x7B, 0x85, 0x13, 0x08, 0x75, 0xDC,
        0x07, 0xF9, 0xBB, 0x30, 0x88, 0x36, 0xD2, 0x30, 0xDE, 0x89, 0x19, 0x83, 0x4A, 0xE2, 0x2C, 0x3E, 0x85, 0xEB, 0xDE, 0x51
    };
    
    NSData *flattenedSignature = [ASNUtils decodeDSASignature: [NSData dataWithBytes: encodedSignature length: sizeof encodedSignature]];
    
    XCTAssertEqualObjects(
        [NSData dataWithBytes: expectedFlattenedSignature length: sizeof expectedFlattenedSignature],
        flattenedSignature
    );
}

- (void) testDecodeDSASignatureWithSmallerNumbers
{
    unsigned char encodedSignature[] = {
        0x30, 0x29,
        0x02, 0x13,     0x2A, 0x0B, 0xEE, 0xED, 0x98, 0x79, 0x7C, 0x04, 0x2B, 0x8E, 0x4C, 0x37, 0xC4, 0x7B, 0x85, 0x13, 0x08, 0x75, 0xDC,
        0x02, 0x12,     0xBB, 0x30, 0x88, 0x36, 0xD2, 0x30, 0xDE, 0x89, 0x19, 0x83, 0x4A, 0xE2, 0x2C, 0x3E, 0x85, 0xEB, 0xDE, 0x51
    };

    unsigned char expectedFlattenedSignature[] = {
        0x00, 0x2A, 0x0B, 0xEE, 0xED, 0x98, 0x79, 0x7C, 0x04, 0x2B, 0x8E, 0x4C, 0x37, 0xC4, 0x7B, 0x85, 0x13, 0x08, 0x75, 0xDC,
        0x00, 0x00, 0xBB, 0x30, 0x88, 0x36, 0xD2, 0x30, 0xDE, 0x89, 0x19, 0x83, 0x4A, 0xE2, 0x2C, 0x3E, 0x85, 0xEB, 0xDE, 0x51
    };
    
    NSData *flattenedSignature = [ASNUtils decodeDSASignature: [NSData dataWithBytes: encodedSignature length: sizeof encodedSignature]];
    
    XCTAssertEqualObjects(
        [NSData dataWithBytes: expectedFlattenedSignature length: sizeof expectedFlattenedSignature],
        flattenedSignature
    );
}

- (void) testEncodeDSASignature
{
    unsigned char flattenedSignature[] = {
        0x4D, 0x2A, 0x0B, 0xEE, 0xED, 0x98, 0x79, 0x7C, 0x04, 0x2B, 0x8E, 0x4C, 0x37, 0xC4, 0x7B, 0x85, 0x13, 0x08, 0x75, 0xDC,
        0x07, 0xF9, 0xBB, 0x30, 0x88, 0x36, 0xD2, 0x30, 0xDE, 0x89, 0x19, 0x83, 0x4A, 0xE2, 0x2C, 0x3E, 0x85, 0xEB, 0xDE, 0x51
    };

    unsigned char expectedEncodedSignature[] = {
        0x30, 0x2C, 0x02, 0x14, 0x4D, 0x2A, 0x0B, 0xEE, 0xED, 0x98, 0x79, 0x7C, 0x04, 0x2B, 0x8E, 0x4C,
        0x37, 0xC4, 0x7B, 0x85, 0x13, 0x08, 0x75, 0xDC, 0x02, 0x14, 0x07, 0xF9, 0xBB, 0x30, 0x88, 0x36,
        0xD2, 0x30, 0xDE, 0x89, 0x19, 0x83, 0x4A, 0xE2, 0x2C, 0x3E, 0x85, 0xEB, 0xDE, 0x51
    };

    NSData *encodedSignature = [ASNUtils encodeDSASignature: [NSData dataWithBytes: flattenedSignature length: sizeof flattenedSignature]];

    XCTAssertEqualObjects(
        [NSData dataWithBytes: expectedEncodedSignature length: sizeof expectedEncodedSignature],
        encodedSignature
    );
}

- (void) testEncodeDSASignatureWithPaddedNumbers
{
    unsigned char flattenedSignature[] = {
        0x00, 0x2A, 0x0B, 0xEE, 0xED, 0x98, 0x79, 0x7C, 0x04, 0x2B, 0x8E, 0x4C, 0x37, 0xC4, 0x7B, 0x85, 0x13, 0x08, 0x75, 0xDC,
        0x00, 0x00, 0xBB, 0x30, 0x88, 0x36, 0xD2, 0x30, 0xDE, 0x89, 0x19, 0x83, 0x4A, 0xE2, 0x2C, 0x3E, 0x85, 0xEB, 0xDE, 0x51
    };

    unsigned char expectedEncodedSignature[] = {
        0x30, 0x29,
        0x02, 0x13,     0x2A, 0x0B, 0xEE, 0xED, 0x98, 0x79, 0x7C, 0x04, 0x2B, 0x8E, 0x4C, 0x37, 0xC4, 0x7B, 0x85, 0x13, 0x08, 0x75, 0xDC,
        0x02, 0x12,     0xBB, 0x30, 0x88, 0x36, 0xD2, 0x30, 0xDE, 0x89, 0x19, 0x83, 0x4A, 0xE2, 0x2C, 0x3E, 0x85, 0xEB, 0xDE, 0x51
    };

    NSData *encodedSignature = [ASNUtils encodeDSASignature: [NSData dataWithBytes: flattenedSignature length: sizeof flattenedSignature]];

    XCTAssertEqualObjects(
        [NSData dataWithBytes: expectedEncodedSignature length: sizeof expectedEncodedSignature],
        encodedSignature
    );
}

@end
